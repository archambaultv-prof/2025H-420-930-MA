---
sidebar_label: Notation grand O
sidebar_position: 2
description: Notation grand O
---


# ğŸ“ˆ ComplexitÃ© et structures de contrÃ´le

## ğŸ¯ Objectif pÃ©dagogique

* CrÃ©er un projet Python Ã  l'aide de uv
* Comprendre le concept de complexitÃ© algorithmique (notation grand O)
* Savoir estimer la complexitÃ© temporelle dâ€™un algorithme simple
* Relier la complexitÃ© Ã  la structure du code (boucles, conditions, appels de fonction)
* Comparer lâ€™efficacitÃ© de diffÃ©rents algorithmes

## ğŸ” Partie 1 â€“ Introduction guidÃ©e

### ğŸ“š Lecture et exploration

Lisez les deux sections suivantes :

### ğŸ§  1. Quâ€™est-ce que la notation grand O ?

La notation **O(...)** sert Ã  estimer comment le **temps dâ€™exÃ©cution** dâ€™un
algorithme croÃ®t en fonction de la taille de lâ€™entrÃ©e. On cherche Ã  rÃ©pondre Ã 
cette question :

> Â« Si je double la taille de mes donnÃ©es, combien de fois plus longtemps mon programme prendra-t-il Ã  sâ€™exÃ©cuter ? Â»

Exemples :

* `O(1)` : temps constant â€“ ne dÃ©pend pas de la taille de lâ€™entrÃ©e
* `O(n)` : temps linÃ©aire â€“ si on double lâ€™entrÃ©e, le temps double
* `O(nÂ²)` : temps quadratique â€“ si on double lâ€™entrÃ©e, le temps est multipliÃ© par 4

### ğŸ§  2. RÃ¨gles gÃ©nÃ©rales pour estimer la complexitÃ©

Voici quelques rÃ¨gles utiles :

| Structure                                     | ComplexitÃ© approximative |
| --------------------------------------------- | ------------------------ |
| Instruction simple                            | `O(1)`                   |
| Boucle `for i in range(n)`                    | `O(n)`                   |
| Boucle imbriquÃ©e `for i in range(n): for j in range(m)` | `O(n * m)`               |
| Appel rÃ©cursif sur moitiÃ© (`n // 2`)          | `O(log n)`               |
| Double rÃ©cursion (ex. : Fibonacci)            | `O(2^n)`                 |

Note : on ne compte **que les parties les plus coÃ»teuses** (on garde le terme
dominant).

## ğŸ”¨ Partie 2 â€“ Analyse de code

### âœï¸ Instructions

Pour chaque extrait de code suivant, **indiquez la complexitÃ© temporelle en
notation grand O**, en justifiant votre rÃ©ponse.

### ğŸ“„ Extraits

```python
# Extrait A
def somme(liste):
    total = 0
    for x in liste:
        total += x
    return total
```

```python
# Extrait B
def produit_matrices(A, B):
    n = len(A)
    m = len(B[0])
    p = len(B)
    resultat = [[0] * m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            for k in range(p):
                resultat[i][j] += A[i][k] * B[k][j]
    return resultat
```

```python
# Extrait C
def cherche(x, liste):
    for i in range(len(liste)):
        if liste[i] == x:
            return True
    return False
```

```python
# Extrait D
def mystere(n):
    i = 1
    while i < n:
        i *= 2
    return i
```

---

## ğŸ§ª Partie 3 â€“ ExpÃ©rimentation

### ğŸ§‘â€ğŸ’» TÃ¢che

1. CrÃ©ez un nouveau projet Python avec `uv`.

2. Configurez un script principal `main`. Ce script pourra Ãªtre exÃ©cutÃ© avec la commande `uv run main`.

3. Ã‰crivez un programme Python qui compare le **temps dâ€™exÃ©cution** de deux fonctions que vous recevrez en paramÃ¨tre.
   Pour les plus aventuriers, vous pouvez mÃªme vous faire un fichier `fonctions.py` qui contient des fonctions et votre
   programme principal les dÃ©couvre grÃ¢ce au module `inspect`.

4. Mesurez le **temps dâ€™exÃ©cution** des deux fonctions pour des valeurs croissantes de `n` (ex. : 100, 200, 400, 800â€¦)

5. Sauvegardez les rÃ©sultats dans un fichier CSV avec les colonnes `n`, `fonction1`, `fonction2`.

5. Sauvegardez un graphique comparatif avec `matplotlib`.

### ğŸ’¡ Aide

Vous pouvez utiliser :

```python
import time

debut = time.time()
# votre code ici
fin = time.time()
print("DurÃ©e :", fin - debut)
```
