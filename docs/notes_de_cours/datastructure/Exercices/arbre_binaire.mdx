---
sidebar_position: 4
sidebar_label: Arbre binaire
description: Arbre binaire
---

# ğŸŒ³ Arbre binaire

## ğŸ¯ Objectifs pÃ©dagogiques

- Comprendre les structures de donnÃ©es de type arbre binaire.
- Savoir implÃ©menter un arbre binaire en Python.
- Apprendre Ã  parcourir un arbre binaire (prÃ©fixe, infixe, postfixe).
- Savoir insÃ©rer et supprimer des nÅ“uds dans un arbre binaire.

## ğŸ“œ Ã‰noncÃ©

Vous allez crÃ©er un **arbre binaire de recherche** (Binary Search Tree - BST),
câ€™est-Ã -dire un arbre binaire tel que pour chaque nÅ“ud :

* les valeurs du **sous-arbre gauche** sont strictement **infÃ©rieures** Ã  la valeur du nÅ“ud,
* les valeurs du **sous-arbre droit** sont **supÃ©rieures ou Ã©gales** Ã  la valeur du nÅ“ud.


### ğŸ§© Partie 1 â€” ImplÃ©mentation de la structure

1. ImplÃ©mentez une classe `Node` reprÃ©sentant un nÅ“ud de lâ€™arbre avec :

    * un attribut `val` (valeur),
    * un attribut `left` (fils gauche),
    * un attribut `right` (fils droit).

2. ImplÃ©mentez une classe `BinarySearchTree` avec :

    * un attribut `root` (racine de lâ€™arbre),
    * une mÃ©thode `insert(val)` pour insÃ©rer une valeur selon les rÃ¨gles du BST,
    * une mÃ©thode `delete(val)` pour supprimer un nÅ“ud (voir note plus bas).
    * une mÃ©thode `contains(val)` qui retourne `True` si la valeur est dans lâ€™arbre.
    * une mÃ©thode `height()` qui retourne la hauteur de lâ€™arbre. C'est-Ã -dire
      le nombre maximal de niveaux de l'arbre, oÃ¹ la racine est au niveau 0.

La suppression doit gÃ©rer trois cas :

    * Le nÅ“ud Ã  supprimer est une **feuille** (aucun enfant),
    * Le nÅ“ud a **un seul enfant** (remplacer par lâ€™enfant),
    * Le nÅ“ud a **deux enfants** (remplacer par son successeur immÃ©diat, câ€™est-Ã -dire la plus petite valeur de son sous-arbre droit).


### ğŸ” Partie 2 â€” Parcours de lâ€™arbre

Ajoutez Ã  la classe `BinarySearchTree` trois mÃ©thodes pour parcourir lâ€™arbre et afficher les valeurs dans lâ€™ordre appropriÃ© :

* `traverse_inorder()`: parcours **infixe** (gauche, racine, droite),
* `traverse_preorder()`: parcours **prÃ©fixe** (racine, gauche, droite),
* `traverse_postorder()`: parcours **postfixe** (gauche, droite, racine).


### ğŸ§ª Partie 3 â€” Tests et dÃ©monstration

CrÃ©ez des tests pour vÃ©rifier le bon fonctionnement de votre implÃ©mentation. Par exemple :

1. CrÃ©ez un arbre Ã  partir des valeurs suivantes, insÃ©rÃ©es dans cet ordre :
   `50, 30, 70, 20, 40, 60, 80`

2. Afficher et vÃ©rifier lâ€™arbre selon les trois types de parcours.

3. Supprimez les nÅ“uds suivants dans cet ordre : `20`, `30`, `50`

4. RÃ©affichez et revÃ©rifier lâ€™arbre aprÃ¨s chaque suppression.

## ğŸ“ Pour vous aidez

Si vous Ãªtes bloquÃ©, voici quelques ressources utiles :

:::warning

Attention, ne pas simplement copier-coller le code de ces ressources. Essayez
de l'Ã©crire par vous-mÃªme en vous inspirant des exemples.

:::

- [GeeksforGeeks - Binary Search Tree](https://www.geeksforgeeks.org/binary-search-tree-in-python/)
- [w3schools](https://www.w3schools.com/dsa/dsa_data_binarysearchtrees.php)