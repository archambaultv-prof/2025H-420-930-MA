---
sidebar_position: 7
sidebar_label: Patron dÃ©corateur
description: Patron dÃ©corateur
---

# ğŸ Patron dÃ©corateur (Decorator)

Le patron DÃ©corateur permet dâ€™**ajouter dynamiquement des responsabilitÃ©s**
(comportements) Ã  un objet sans changer son interface ni modifier sa classe. Il
sâ€™agit dâ€™une alternative souple Ã  lâ€™hÃ©ritage pour lâ€™extension.

IdÃ©e clÃ© : on encapsule lâ€™objet cible dans un ou plusieurs Â« dÃ©corateurs Â» qui
implÃ©mentent la mÃªme interface et dÃ©lÃ¨guent tout ou partie des appels Ã  lâ€™objet
encapsulÃ©, en ajoutant du traitement avant ou aprÃ¨s la dÃ©lÃ©gation.

---

## Quand lâ€™utiliser ?

- Pour ajouter des fonctionnalitÃ©s de faÃ§on **optionnelle et combinable** (ex.
  journalisation, cache, validation, chiffrement, compression).
- Quand lâ€™**hÃ©ritage** produit une explosion de sous-classes (combinaisons de
  comportements).
- Pour **ouvrir** un objet Ã  des extensions sans modifier son code (OCP).
- Pour **varier lâ€™ordre** dâ€™application des responsabilitÃ©s Ã  lâ€™exÃ©cution.

---

## Diagramme de classes

```mermaid
classDiagram
    class Composant {
        +operation(): any
    }
    class ComposantConcret {
        +operation(): any
    }
    class Decorateur {
        -wrappee: Composant
        +operation(): any
    }
    class DecorateurA {
        +operation(): any
    }
    class DecorateurB {
        +operation(): any
    }

    Composant <|.. ComposantConcret
    Composant <|.. Decorateur
    Decorateur <|-- DecorateurA
    Decorateur <|-- DecorateurB
    Decorateur --> Composant : dÃ©lÃ¨gue
```

Le client dÃ©pend uniquement de `Composant`. Les dÃ©corateurs ajoutent des
responsabilitÃ©s sans changer lâ€™interface.

### Explication du diagramme

- `Composant` : interface (ou classe abstraite) utilisÃ©e par le client.
- `ComposantConcret` : implÃ©mentation de base.
- `Decorateur` : classe de base des dÃ©corateurs, contient une rÃ©fÃ©rence vers un
  `Composant` (la Â« wrappee Â») et dÃ©lÃ¨gue par dÃ©faut.
- `DecorateurA` / `DecorateurB` : dÃ©corateurs concrets ajoutant des comportements avant/aprÃ¨s la dÃ©lÃ©gation.
- Les dÃ©corateurs peuvent Ãªtre empilÃ©s (chaÃ®nÃ©s) pour composer des
  responsabilitÃ©s.

---

## Exemple d'implÃ©mentations en Python

### DÃ©corateurs dâ€™envoi de notifications (journalisation et antispam)

Un exemple montrant lâ€™ajout de responsabilitÃ©s.

```python
from abc import ABC, abstractmethod
import time

class Notificateur(ABC):
    @abstractmethod
    def envoyer(self, message: str) -> None: ...

class EmailNotificateur(Notificateur):
    def envoyer(self, message: str) -> None:
        print(f"[EMAIL] {message}")

class NotificateurDecorateur(Notificateur):
    def __init__(self, wrappee: Notificateur):
        self._wrappee = wrappee

    def envoyer(self, message: str) -> None:
        self._wrappee.envoyer(message)

class JournalisationDecorateur(NotificateurDecorateur):
    def envoyer(self, message: str) -> None:
        print(f"[LOG {time.strftime('%H:%M:%S')}] avant envoi")
        super().envoyer(message)
        print("[LOG] aprÃ¨s envoi")

class AntiSpamDecorateur(NotificateurDecorateur):
    def __init__(self, wrappee: Notificateur, intervalle_s: float = 1.0):
        super().__init__(wrappee)
        self._intervalle = intervalle_s
        self._dernier = 0.0

    def envoyer(self, message: str) -> None:
        maintenant = time.time()
        if maintenant - self._dernier < self._intervalle:
            print("[SPAM BLOQUÃ‰]")
            return
        self._dernier = maintenant
        super().envoyer(message)

# Composition Ã  la volÃ©e
notif: Notificateur = EmailNotificateur()
notif = JournalisationDecorateur(AntiSpamDecorateur(notif, intervalle_s=0.5))
notif.envoyer("Bonjour")
notif.envoyer("Bonjour")  # probablement bloquÃ© selon le timing
```

---

## Avantages et inconvÃ©nients

**Avantages**
- Ajout de fonctionnalitÃ©s sans modifier les classes existantes (OCP).
- Combinaison flexible de responsabilitÃ©s Ã  lâ€™exÃ©cution.
- Favorise la composition plutÃ´t que lâ€™hÃ©ritage.

**InconvÃ©nients**
- Multiplication de petits objets chaÃ®nÃ©s, **plus difficile Ã  dÃ©boguer**.
- Lâ€™ordre dâ€™empilage peut Ãªtre source de bugs subtils.
- Peut compliquer la configuration et la lisibilitÃ© si surâ€‘utilisÃ©.

---

## Astuces pratiques

- Garder lâ€™interface du dÃ©corateur strictement **transparente** (mÃªme contrat que le composant).
- PrÃ©fÃ©rer un **dÃ©corateur de base** qui dÃ©lÃ¨gue par dÃ©faut, pour Ã©viter de rÃ©pÃ©ter du code.
- Documenter lâ€™**ordre recommandÃ©** dâ€™empilage et, si possible, fournir des constructeurs utilitaires.
- Ã‰viter dâ€™exposer la Â« wrappee Â» au client pour ne pas recoupler inutilement.


---

## RÃ©fÃ©rences

- https://refactoring.guru/design-patterns/decorator
- https://en.wikipedia.org/wiki/Decorator_pattern

