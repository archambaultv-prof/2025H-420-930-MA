---
sidebar_position: 1
sidebar_label: Principes SOLID
description: Principes SOLID
---

# üí™ Principes SOLID

## Introduction aux principes SOLID

Les principes SOLID ont √©t√© popularis√©s par Robert C. Martin (¬´ Uncle Bob ¬ª).
Ils sont un ensemble de cinq principes de conception orient√©e objet qui visent
√† am√©liorer la qualit√© du code et sa maintenabilit√©. Le terme **SOLID** est un
acronyme pour :

  - **S**ingle Responsibility  
  - **O**pen/Closed  
  - **L**iskov Substitution  
  - **I**nterface Segregation  
  - **D**ependency Inversion  

Ces principes visent √† rendre votre code :

- **Flexible** ‚Äì facile √† faire √©voluer  
- **Lisible** ‚Äì simple √† comprendre  
- **Testable** ‚Äì propice aux tests unitaires  

## 1. SRP ‚Äì Principe de Responsabilit√© Unique

### Concept

Une classe ne devrait avoir qu‚Äôune seule raison de changer, c‚Äôest-√†-dire
qu‚Äôelle ne doit couvrir qu‚Äôune seule responsabilit√©.

### Exemple

#### Violation  
```python
class Facture:
    def __init__(self, montant):
        self.montant = montant

    def calculer_taxes(self):
        return self.montant * 0.2

    def enregistrer(self):
        # SQL pour enregistrer la facture
        pass

    def envoyer_email(self, email_client):
        # SMTP pour envoyer la facture
        pass
```

Ici, `Facture` g√®re √† la fois la logique m√©tier, la persistance et l‚Äôenvoi d‚Äôemails.

#### Refactorisation

```python
class Facture:
    def __init__(self, montant):
        self.montant = montant

class CalculateurTaxes:
    TAUX = 0.2
    def calculer(self, facture: Facture) -> float:
        return facture.montant * self.TAUX

class FactureRepository:
    def enregistrer(self, facture: Facture):
        # SQL
        pass

class ServiceEmail:
    def envoyer(self, destinataire: str, contenu: str):
        # SMTP
        pass
```

Chaque classe a maintenant **une** responsabilit√© bien d√©finie.

## 2. OCP ‚Äì Principe Open/Closed

### Concept

Les entit√©s doivent √™tre **ouvertes √† l‚Äôextension** (ajout de fonctionnalit√©s)
mais **ferm√©es √† la modification** de leur code source existant.

### Exemple

#### Violation

```python
class Facture:
    def __init__(self, montant, type_client):
        self.montant = montant
        self.type = type_client

    def calculer_remise(self):
        if self.type == 'VIP':
            return self.montant * 0.1
        elif self.type == 'Regular':
            return self.montant * 0.05
        else:
            return 0
```

Ajouter un nouveau type de remise force √† modifier `calculer_remise()`.

#### Refactorisation (pattern Strat√©gie)

```python
from abc import ABC, abstractmethod

class StrategieRemise(ABC):
    @abstractmethod
    def calculer(self, montant: float) -> float:
        pass

class RemiseVIP(StrategieRemise):
    def calculer(self, montant):
        return montant * 0.1

class RemiseRegular(StrategieRemise):
    def calculer(self, montant):
        return montant * 0.05

class Facture:
    def __init__(self, montant, strategie: StrategieRemise):
        self.montant = montant
        self.strategie = strategie

    def calculer_remise(self):
        return self.strategie.calculer(self.montant)
```

Pour ajouter une nouvelle remise, on cr√©e simplement une sous-classe de
`StrategieRemise`.

## 3. LSP ‚Äì Principe de Substitution de Liskov

### Concept

Une sous-classe doit pouvoir remplacer sa super-classe sans que le comportement
attendu du programme n‚Äôen soit alt√©r√©.

### Exemple

#### Violation

```python
class Oiseau:
    def voler(self):
        print("Je vole")

class Autruche(Oiseau):
    def voler(self):
        raise NotImplementedError("Je ne peux pas voler")
```

L‚Äô`Autruche` ne respecte pas l‚ÄôAPI `voler()` de `Oiseau`.

#### Refactorisation

```python
from abc import ABC, abstractmethod

class Oiseau(ABC):
    @abstractmethod
    def deplacer(self):
        pass

class OiseauVolant(Oiseau):
    def deplacer(self):
        print("Je vole")

class Autruche(Oiseau):
    def deplacer(self):
        print("Je cours")
```

On passe par une m√©thode plus g√©n√©rale `deplacer()`, que chaque oiseau
impl√©mente √† sa fa√ßon.

## 4. ISP ‚Äì Principe de S√©gr√©gation d‚ÄôInterface

### Concept

Pr√©f√©rez plusieurs interfaces sp√©cifiques et coh√©sives plut√¥t qu‚Äôune interface
unique et volumineuse.

### Exemple

#### Violation

```python
class Imprimante:
    def imprimer(self, doc): pass
    def scanner(self, doc): pass
    def faxer(self, doc): pass

class ImprimanteBasique(Imprimante):
    def imprimer(self, doc): pass
    def scanner(self, doc):
        raise NotImplementedError
    def faxer(self, doc):
        raise NotImplementedError
```

`ImprimanteBasique` est forc√©e d‚Äôimpl√©menter des m√©thodes inutiles.

#### Refactorisation

```python
from abc import ABC, abstractmethod

class IImpression(ABC):
    @abstractmethod
    def imprimer(self, doc): pass

class IScan(ABC):
    @abstractmethod
    def scanner(self, doc): pass

class IFax(ABC):
    @abstractmethod
    def faxer(self, doc): pass

class ImprimanteBasique(IImpression):
    def imprimer(self, doc): pass

class ImprimanteMultifonction(IImpression, IScan, IFax):
    def imprimer(self, doc): pass
    def scanner(self, doc): pass
    def faxer(self, doc): pass
```

Chaque imprimante impl√©mente uniquement les interfaces dont elle a besoin.


## 5. DIP ‚Äì Principe d‚ÄôInversion de D√©pendance

### Concept

1. Les modules de haut niveau ne d√©pendent pas de modules de bas niveau : tous
   deux d√©pendent d‚Äôabstractions.
2. Les d√©tails (impl√©mentations concr√®tes) doivent d√©pendre d‚Äôabstractions, et
   non l‚Äôinverse.

### Exemple

#### Violation

```python
class MySQLClient:
    def connecter(self): pass

class ServiceUtilisateur:
    def __init__(self):
        self.db = MySQLClient()  # d√©pendance trop concr√®te

    def enregistrer(self, utilisateur):
        self.db.connecter()
        # ...
```

Le service est li√© √† MySQL, on ne peut pas changer de base de donn√©es sans
modifier `ServiceUtilisateur`.

#### Refactorisation

```python
from abc import ABC, abstractmethod

class DBClient(ABC):
    @abstractmethod
    def connecter(self): pass

class MySQLClient(DBClient):
    def connecter(self): pass

class SQLiteClient(DBClient):
    def connecter(self): pass

class ServiceUtilisateur:
    def __init__(self, db_client: DBClient):
        self.db = db_client

    def enregistrer(self, utilisateur):
        self.db.connecter()
        # ...
```

On injecte la d√©pendance via le constructeur et on peut facilement passer d‚Äôun
client MySQL √† SQLite.

## Conclusion

Vous venez de parcourir les cinq principes SOLID :

1. **SRP** : responsabilit√© unique
2. **OCP** : ouvert/ferm√©
3. **LSP** : substitution de Liskov
4. **ISP** : s√©gr√©gation d‚Äôinterface
5. **DIP** : inversion de d√©pendance
