---
sidebar_position: 3
sidebar_label: Injection des d√©pendances
description: Injection des d√©pendances
---


# üíâ Injection des d√©pendances

L'injection des d√©pendances est un patron de conception qui permet de fournir
les d√©pendances d'un objet depuis l'ext√©rieur plut√¥t que de les cr√©er
directement dans l'objet. Cela am√©liore la flexibilit√©, la testabilit√© et
r√©duit le couplage entre les classes.

## Principe de base

Au lieu qu'une classe cr√©e ses propres d√©pendances, elles lui sont "inject√©es"
par un m√©canisme externe.

### Sans injection de d√©pendances

```python
class Logger:
    def log(self, message):
        print(f"LOG: {message}")

class EmailService:
    def __init__(self):
        self.logger = Logger()  # D√©pendance hard-cod√©e
    
    def send_email(self, to, subject, body):
        self.logger.log(f"Envoi email √† {to}")
        # logique d'envoi...
```

### Avec injection de d√©pendances

```python
class Logger:
    def log(self, message):
        print(f"LOG: {message}")

class EmailService:
    def __init__(self, logger):  # D√©pendance inject√©e
        self.logger = logger
    
    def send_email(self, to, subject, body):
        self.logger.log(f"Envoi email √† {to}")
        # logique d'envoi...

# Utilisation
logger = Logger()
email_service = EmailService(logger)
```

## Types d'injection

### 1. Injection par constructeur

La d√©pendance est fournie lors de la cr√©ation de l'objet :

```python
class DatabaseService:
    def __init__(self, connection):
        self.connection = connection
    
    def save_user(self, user):
        # utilise self.connection
        pass

# Utilisation
connection = DatabaseConnection("localhost")
db_service = DatabaseService(connection)
```

### 2. Injection par propri√©t√© (setter)

La d√©pendance est assign√©e apr√®s la cr√©ation :

```python
class ReportGenerator:
    def __init__(self):
        self._data_source = None
    
    @property
    def data_source(self):
        return self._data_source
    
    @data_source.setter
    def data_source(self, value):
        self._data_source = value
    
    def generate_report(self):
        if self._data_source is None:
            raise ValueError("Data source not set")
        # g√©n√®re le rapport...

# Utilisation
report_gen = ReportGenerator()
report_gen.data_source = DatabaseSource()
```

### 3. Injection par m√©thode

La d√©pendance est pass√©e en param√®tre √† chaque appel :

```python
class PaymentProcessor:
    def process_payment(self, amount, payment_method):
        # payment_method est inject√© √† chaque appel
        return payment_method.charge(amount)

# Utilisation
processor = PaymentProcessor()
processor.process_payment(100, CreditCardMethod())
processor.process_payment(50, PaypalMethod())
```

## Avantages

### 1. Testabilit√© am√©lior√©e

```python
# Mock pour les tests
class MockLogger:
    def __init__(self):
        self.messages = []
    
    def log(self, message):
        self.messages.append(message)

# Test unitaire
def test_email_service():
    mock_logger = MockLogger()
    email_service = EmailService(mock_logger)
    
    email_service.send_email("test@example.com", "Test", "Body")
    
    assert len(mock_logger.messages) == 1
    assert "test@example.com" in mock_logger.messages[0]
```

### 2. Flexibilit√© et r√©utilisabilit√©

```python
# Diff√©rentes impl√©mentations de logger
class FileLogger:
    def log(self, message):
        with open("app.log", "a") as f:
            f.write(f"{message}\n")

class DatabaseLogger:
    def __init__(self, db_connection):
        self.db = db_connection
    
    def log(self, message):
        self.db.execute("INSERT INTO logs (message) VALUES (?)", (message,))

# M√™me service, diff√©rents loggers
email_service_console = EmailService(Logger())
email_service_file = EmailService(FileLogger())
email_service_db = EmailService(DatabaseLogger(db_conn))
```

### 3. Respect du principe ouvert/ferm√©

Le code est ouvert √† l'extension (nouvelles impl√©mentations) mais ferm√© √† la modification.

## Conteneur d'injection (DI Container)

Pour les applications complexes, on peut utiliser un conteneur qui g√®re automatiquement les d√©pendances :

```python
class DIContainer:
    def __init__(self):
        self._services = {}
        self._singletons = {}
    
    def register(self, interface, implementation, singleton=False):
        self._services[interface] = (implementation, singleton)
    
    def resolve(self, interface):
        if interface not in self._services:
            raise ValueError(f"Service {interface} not registered")
        
        implementation, is_singleton = self._services[interface]
        
        if is_singleton:
            if interface not in self._singletons:
                self._singletons[interface] = implementation()
            return self._singletons[interface]
        
        return implementation()

# Configuration
container = DIContainer()
container.register("logger", Logger, singleton=True)
container.register("email_service", 
                  lambda: EmailService(container.resolve("logger")))

# Utilisation
email_service = container.resolve("email_service")
```

## Bonnes pratiques

### 1. Utiliser des interfaces/protocoles

```python
from abc import ABC, abstractmethod

class LoggerInterface(ABC):
    @abstractmethod
    def log(self, message: str) -> None:
        pass

class ConsoleLogger(LoggerInterface):
    def log(self, message: str) -> None:
        print(f"LOG: {message}")

class EmailService:
    def __init__(self, logger: LoggerInterface):
        self.logger = logger
```

### 2. √âviter la sur-injection

Ne pas injecter des d√©pendances pour des classes tr√®s simples ou des types primitifs.

### 3. Pr√©f√©rer l'injection par constructeur

Plus explicite et garantit que l'objet est dans un √©tat valide d√®s sa cr√©ation.

## Comparaison avec le singleton

| Aspect | Singleton | Injection des d√©pendances |
|--------|-----------|---------------------------|
| **Couplage** | Fort (d√©pendance hard-cod√©e) | Faible (d√©pendance externe) |
| **Testabilit√©** | Difficile (√©tat global) | Facile (mocks/stubs) |
| **Flexibilit√©** | Limit√©e (une seule impl√©mentation) | √âlev√©e (multiples impl√©mentations) |
| **R√©utilisabilit√©** | Faible | √âlev√©e |
| **Complexit√©** | Simple | Plus complexe (configuration) |

## Quand utiliser l'injection des d√©pendances

- **Applications avec besoins de tests unitaires**
- **Syst√®mes n√©cessitant diff√©rentes configurations**
- **Code devant √™tre flexible et √©volutif**
- **Quand on veut d√©coupler les composants**
