---
sidebar_position: 11
sidebar_label: Patron state
description: Patron state
---

# ğŸ”„ Patron State

Le patron State permet Ã  un objet de changer son comportement lorsque son
**Ã©tat interne** change. PlutÃ´t que dâ€™avoir des blocs conditionnels partout, le
Contexte dÃ©lÃ¨gue Ã  un objet Ã‰tat qui encapsule la logique liÃ©e Ã  cet Ã©tat et
peut dÃ©cider des transitions.

IdÃ©e clÃ©: remplacer les `if/elif` sur une variable `etat` par des classes Ã‰tat spÃ©cialisÃ©es.

---

## Quand lâ€™utiliser ?

- Quand le comportement dÃ©pend fortement de lâ€™Ã©tat courant (machine Ã  Ã©tats
  finis).
- Quand on voit des conditions rÃ©pÃ©tÃ©es qui testent `etat` pour dÃ©cider quoi
  faire.
- Pour ajouter facilement de nouveaux Ã©tats/comportements sans toucher au code
  client (OCP).
- Pour rendre explicites les transitions et faciliter les tests.

---

## Diagramme de classes

```mermaid
classDiagram
    class Contexte {
        - etat: Etat
        + set_etat(e: Etat)
        + requete1()
        + requete2()
    }

    class Etat {
        <<interface>>
        + handle1(ctx: Contexte)
        + handle2(ctx: Contexte)
    }

    class EtatConcretA {
        + handle1(ctx: Contexte)
        + handle2(ctx: Contexte)
    }

    class EtatConcretB {
        + handle1(ctx: Contexte)
        + handle2(ctx: Contexte)
    }

    Contexte --> Etat : dÃ©lÃ¨gue
    Etat <|.. EtatConcretA
    Etat <|.. EtatConcretB
```

- `Etat` : interface (ou classe abstraite) pour le comportement dÃ©pendant de lâ€™Ã©tat.
- `EtatConcretA/B` : implÃ©mentent la logique propre Ã  chaque Ã©tat et les transitions.
- `Contexte` : pointe sur lâ€™Ã©tat courant et dÃ©lÃ¨gue lâ€™API publique.

---

## ImplÃ©mentations en Python

### Lecteur audio (arrÃªt/lecture/pause)

```python
from abc import ABC, abstractmethod

class Lecteur:
    def __init__(self):
        self._etat: EtatLecteur = Arret()
    def set_etat(self, e: EtatLecteur) -> None:
        self._etat = e
    def play(self): self._etat.play(self)
    def pause(self): self._etat.pause(self)
    def stop(self): self._etat.stop(self)

class EtatLecteur(ABC):
    @abstractmethod
    def play(self, ctx: Lecteur) -> None: ...
    @abstractmethod
    def pause(self, ctx: Lecteur) -> None: ...
    @abstractmethod
    def stop(self, ctx: Lecteur) -> None: ...

class Arret(EtatLecteur):
    def play(self, ctx: Lecteur) -> None:
        print("Arret â†’ Lecture")
        ctx.set_etat(Lecture())
    def pause(self, ctx: Lecteur) -> None:
        print("Arret: pause sans effet")
    def stop(self, ctx: Lecteur) -> None:
        print("Arret: dÃ©jÃ  stoppÃ©")

class Lecture(EtatLecteur):
    def play(self, ctx: Lecteur) -> None:
        print("Lecture: dÃ©jÃ  en lecture")
    def pause(self, ctx: Lecteur) -> None:
        print("Lecture â†’ Pause")
        ctx.set_etat(Pause())
    def stop(self, ctx: Lecteur) -> None:
        print("Lecture â†’ Arret")
        ctx.set_etat(Arret())

class Pause(EtatLecteur):
    def play(self, ctx: Lecteur) -> None:
        print("Pause â†’ Lecture")
        ctx.set_etat(Lecture())
    def pause(self, ctx: Lecteur) -> None:
        print("Pause: dÃ©jÃ  en pause")
    def stop(self, ctx: Lecteur) -> None:
        print("Pause â†’ Arret")
        ctx.set_etat(Arret())

mp = Lecteur()
mp.play()
mp.pause()
mp.play()
mp.stop()
```

---

## State vs Strategy

- Strategy: on choisit lâ€™algorithme de lâ€™extÃ©rieur; pas de transitions internes.
- State: transitions internes gouvernent le changement de comportement.

---

## Avantages et inconvÃ©nients

**Avantages**
- Supprime les conditions massives sur lâ€™Ã©tat.
- Ajout dâ€™Ã©tats/transitions sans casser lâ€™API client (OCP).
- Code plus modulaire et testable.

**InconvÃ©nients**
- Plus de classes/fichiers.
- ModÃ©lisation des transitions requise pour Ã©viter la complexitÃ©.

---

## RÃ©fÃ©rences

- https://refactoring.guru/design-patterns/state
- https://en.wikipedia.org/wiki/State_pattern
- https://www.geeksforgeeks.org/system-design/state-design-pattern/

