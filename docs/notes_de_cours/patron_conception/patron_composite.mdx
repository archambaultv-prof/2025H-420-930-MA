---
sidebar_position: 9
sidebar_label: Patron composite
description: Patron composite
---

# ğŸ§© Patron composite

Le patron composite permet de reprÃ©senter des hiÃ©rarchies Â« partieâ€“tout Â» et de
traiter de maniÃ¨re uniforme des objets simples (feuilles) et des objets
composÃ©s (nÅ“uds composites). Le client utilise la mÃªme interface quâ€™il sâ€™agisse
dâ€™une feuille ou dâ€™un composite, ce qui simplifie le code et favorise le
polymorphisme.

IdÃ©e clÃ© : exposer une interface commune et laisser les composites agrÃ©ger des
composants enfants, tout en se comportant euxâ€‘mÃªmes comme un composant.

---

## Quand lâ€™utiliser ?

- Pour modÃ©liser des structures arborescentes (systÃ¨me de fichiers, DOM,
  expressions mathÃ©matiques, menus).
- Lorsque le client doit pouvoir manipuler indiffÃ©remment une feuille et un
  conteneur via la mÃªme interface.
- Quand on veut appliquer des opÃ©rations rÃ©cursives sur une hiÃ©rarchie
  (afficher, calculer, propager une commande, etc.).
- Pour rÃ©duire les if/elif Â« si feuille alorsâ€¦ sinon compositeâ€¦ Â» dans le client.

---

## Diagramme de classes

```mermaid
classDiagram
	class Composant {
		+operation()
	}
	class Feuille {
		+operation()
	}
	class Composite {
		- enfants: List~Composant~
		+ajouter(c: Composant)
		+retirer(c: Composant)
		+obtenir_enfant(i: int): Composant
		+operation()
	}
	class Client

	Composant <|.. Feuille
	Composant <|.. Composite
	Composite o--> Composant
	Client --> Composant
```

### Explication du diagramme

- `Composant` : interface (ou classe abstraite) commune exposant `operation()`.
- `Feuille` : implÃ©mentation terminale sans enfants.
- `Composite` : contient des `Composant` enfants et implÃ©mente `operation()` en
  dÃ©lÃ©guant/agrÃ©geant les rÃ©sultats de ses enfants.
- `Client` : ne connaÃ®t que `Composant`; il peut traiter une feuille et un
  composite de faÃ§on identique.

---

## ImplÃ©mentations en Python

### Arbre de dossiers/fichiers (affichage rÃ©cursif)

```python
from abc import ABC, abstractmethod
from typing import List

class Noeud(ABC):
	@abstractmethod
	def operation(self, indent: int = 0) -> None: ...

class Fichier(Noeud):
	def __init__(self, nom: str):
		self.nom = nom
	def operation(self, indent: int = 0) -> None:
		print("\t" * indent + f"ğŸ“„ {self.nom}")

class Dossier(Noeud):
	def __init__(self, nom: str):
		self.nom = nom
		self._enfants: List[Noeud] = []
	def ajouter(self, n: Noeud) -> None:
		self._enfants.append(n)
	def retirer(self, n: Noeud) -> None:
		self._enfants.remove(n)
	def operation(self, indent: int = 0) -> None:
		print("\t" * indent + f"ğŸ“ {self.nom}")
		for enfant in self._enfants:
			enfant.operation(indent + 1)

# Client
racine = Dossier("/")
usr = Dossier("usr")
bin = Dossier("bin")
racine.ajouter(usr)
racine.ajouter(bin)
usr.ajouter(Fichier("notes.txt"))
bin.ajouter(Fichier("python.exe"))

racine.operation()
# ğŸ“ /
# 	ğŸ“ usr
# 		ğŸ“„ notes.txt
# 	ğŸ“ bin
# 		ğŸ“„ python.exe
```

Points clÃ©s
- Le client appelle `operation()` sur `Noeud` sans savoir sâ€™il sâ€™agit dâ€™un
  `Fichier` ou dâ€™un `Dossier`.
- `Dossier.operation` propage lâ€™appel rÃ©cursivement.

### Expressions arithmÃ©tiques (Ã©valuation)

```python
from __future__ import annotations
from abc import ABC, abstractmethod

class Expression(ABC):
	@abstractmethod
	def eval(self) -> float: ...

class Nombre(Expression):
	def __init__(self, val: float):
		self.val = val
	def eval(self) -> float:
		return self.val

class Addition(Expression):
	def __init__(self, *enfants: Expression):
		self.enfants = list(enfants)
	def eval(self) -> float:
		return sum(e.eval() for e in self.enfants)

class Multiplication(Expression):
	def __init__(self, *enfants: Expression):
		self.enfants = list(enfants)
	def eval(self) -> float:
		res = 1.0
		for e in self.enfants:
			res *= e.eval()
		return res

# (2 + 3) * (4 + 1) = 25
expr = Multiplication(Addition(Nombre(2), Nombre(3)), Addition(Nombre(4), Nombre(1)))
print(expr.eval())  # 25.0
```

Avantage : lâ€™ajout dâ€™un nouvel opÃ©rateur (ex. `Soustraction`) nâ€™implique pas de
modifier le code client â€” on reste sur `Expression`.

---

## Comparaison rapide avec dÃ©corateur

Tous deux reposent sur une interface commune; le dÃ©corateur enveloppe un
composant pour enrichir son comportement, tandis que le composite agrÃ¨ge des
composants enfants et combine leurs rÃ©sultats.

---

## Avantages et inconvÃ©nients

**Avantages**
- Interface uniforme feuille/composite; simplifie le client.
- Favorise la rÃ©cursivitÃ© et lâ€™extension (ajout de nouveaux types de nÅ“uds).
- RÃ©duction des conditions spÃ©cifiques Â« si feuilleâ€¦ sinon compositeâ€¦ Â».


**InconvÃ©nients**
- Parcours et agrÃ©gations potentiellement coÃ»teux sur de grands arbres.
- DÃ©bogage plus complexe Ã  cause de la rÃ©cursivitÃ© et du polymorphisme (traces
  longues, cycles Ã  Ã©viter).
- Risque dâ€™introduire des cycles si aucune contrainte ne lâ€™empÃªche.

