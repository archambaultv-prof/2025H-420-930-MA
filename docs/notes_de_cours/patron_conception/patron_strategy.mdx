---
sidebar_position: 10
sidebar_label: Patron strategy
description: Patron strategy
---

# ğŸ¯ Patron Strategy

Le patron Strategy permet de dÃ©finir plusieurs faÃ§ons dâ€™exÃ©cuter un mÃªme
comportement et de choisir laquelle utiliser pendant lâ€™exÃ©cution sans avoir Ã 
Ã©crire plein de if/elif.

IdÃ©e clÃ© : dÃ©finir un contrat commun (interface/ABC) pour les algorithmes obtenir 
l'algorithme prÃ©cis via un paramÃ¨tre ou l'injection des dÃ©pendances.

---

## Quand lâ€™utiliser ?

- Plusieurs variantes dâ€™un mÃªme comportement.
- Changer lâ€™algorithme Ã  lâ€™exÃ©cution sans modifier le client.
- Supprimer des conditionnels rÃ©pÃ©titifs de sÃ©lection de comportement.
- Ouvrir la porte Ã  de nouvelles variantes sans toucher au contexte (OCP).
- Tester les algorithmes isolÃ©ment (injection dâ€™une stratÃ©gie simulÃ©e).

---

## Diagramme de classes

```mermaid
classDiagram
	class Strategie {
		+executer(data): any
	}
	class StrategieConcreteA {
		+executer(data): any
	}
	class StrategieConcreteB {
		+executer(data): any
	}
	class Contexte {
		-strategie: Strategie
		+set_strategie(s: Strategie)
		+operation(): any
	}

	Strategie <|.. StrategieConcreteA
	Strategie <|.. StrategieConcreteB
	Contexte --> Strategie
```

- Contexte : contient une rÃ©fÃ©rence Ã  une `Strategie` et lui dÃ©lÃ¨gue la partie
  variable de lâ€™algorithme.
- Strategie : contrat commun que toutes les stratÃ©gies concrÃ¨tes implÃ©mentent.
- StrategieConcreteA/B : variantes dâ€™implÃ©mentation interchangeables.

---

## ImplÃ©mentations en Python

### StratÃ©gie mÃ©tier : politique de taxes

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass

class StrategieTaxe(ABC):
	@abstractmethod
	def calculer(self, sous_total: float) -> float: ...

class TaxeQC(StrategieTaxe):
	# SimplifiÃ©: TPS 5% + TVQ 9.975%
	def calculer(self, sous_total: float) -> float:
		return sous_total * (0.05 + 0.09975)

class TaxeON(StrategieTaxe):
	# HST 13%
	def calculer(self, sous_total: float) -> float:
		return sous_total * 0.13

class SansTaxe(StrategieTaxe):
	def calculer(self, sous_total: float) -> float:
		return 0.0

@dataclass
class Panier:
	articles: list[float]
	strategie_taxe: StrategieTaxe

	def set_strategie(self, s: StrategieTaxe) -> None:
		self.strategie_taxe = s

	def total(self) -> float:
		sous_total = sum(self.articles)
		return sous_total + self.strategie_taxe.calculer(sous_total)

p = Panier([10.0, 25.0, 5.0], TaxeQC())
print(p.total())  # StratÃ©gie QC

p.set_strategie(TaxeON())
print(p.total())  # Bascule vers ON

p.set_strategie(SansTaxe())
print(p.total())  # Exemptions / tests
```

Points notables :
- Le panier dÃ©pend dâ€™une abstraction, pas dâ€™une implÃ©mentation concrÃ¨te.
- Changer de politique de taxes = injection dâ€™une autre stratÃ©gie.

### StratÃ©gie algorithmique : tri

```python
from abc import ABC, abstractmethod
from random import randint

class StrategieTri(ABC):
	@abstractmethod
	def trier(self, donnees: list[int]) -> list[int]: ...

class TriPythonSort(StrategieTri):
	def trier(self, donnees: list[int]) -> list[int]:
		return sorted(donnees)

class TriInsertion(StrategieTri):
	def trier(self, donnees: list[int]) -> list[int]:
		arr = donnees[:]
		for i in range(1, len(arr)):
			cle = arr[i]
			j = i - 1
			while j >= 0 and arr[j] > cle:
				arr[j + 1] = arr[j]
				j -= 1
			arr[j + 1] = cle
		return arr

class ContexteTri:
	def __init__(self, strategie: StrategieTri):
		self._strategie = strategie

	def set_strategie(self, strategie: StrategieTri) -> None:
		self._strategie = strategie

	def executer(self, donnees: list[int]) -> list[int]:
		return self._strategie.trier(donnees)

# DÃ©mo
arr = [randint(0, 100) for _ in range(10)]
ctx = ContexteTri(TriPythonSort())
print("sort:", ctx.executer(arr))

ctx.set_strategie(TriInsertion())
print("insertion:", ctx.executer(arr))
```

Remarques :
- On compare facilement plusieurs algorithmes sur les mÃªmes donnÃ©es.
- Ajouter un nouveau tri = implÃ©menter `StrategieTri` sans modifier `ContexteTri`.

### Variante pythonique : fonctions comme stratÃ©gies

En Python, les fonctions sont des objets de premiÃ¨re classe. On peut utiliser
des `callable` Ã  la place dâ€™une interface formelle.

```python
def taxe_qc(sous_total: float) -> float:
	return sous_total * (0.05 + 0.09975)

def taxe_on(sous_total: float) -> float:
	return sous_total * 0.13

def sans_taxe(sous_total: float) -> float:
	return 0.0

class Panier2:
	def __init__(self, articles: list[float], strategie_taxe):
		self.articles = articles
		self.strategie_taxe = strategie_taxe  # callable

	def set_strategie(self, s):
		self.strategie_taxe = s

	def total(self) -> float:
		sous_total = sum(self.articles)
		return sous_total + self.strategie_taxe(sous_total)

p = Panier2([10, 20], taxe_qc)
print(p.total())
```

---

## DiffÃ©rences avec dâ€™autres patrons

- State : semblable car il change le comportement via un objet; mais State
  modÃ©lise des Ã©tats internes et transitions, alors que Strategy choisit un
  algorithme parmi des alternatives.
- Factory Method / Abstract Factory : sâ€™occupent de crÃ©er des objets; Strategy
  sâ€™occupe de la logique de traitement interchangeable.

---

## Avantages et inconvÃ©nients

Avantages
- Ã‰vite les gros blocs conditionnels en isolant la variation dans des classes
  dÃ©diÃ©es.
- Permet de changer/ajouter des algorithmes sans modifier le contexte (OCP).
- Facilite tests et benchmarks (isolation des variantes).

InconvÃ©nients
- Davantage de classes/objets Ã  gÃ©rer si le cas est simple.
- Le client doit connaÃ®tre et injecter une stratÃ©gie appropriÃ©e.

---

## RÃ©fÃ©rences

- https://refactoring.guru/design-patterns/strategy
- https://en.wikipedia.org/wiki/Strategy_pattern
- https://www.geeksforgeeks.org/system-design/strategy-pattern-set-1/

