---
sidebar_position: 6
sidebar_label: Patron adaptateur
description: Patron adaptateur
---

# üîå Patron adaptateur (Adapter)

Le patron Adaptateur fait collaborer des interfaces incompatibles en
**convertissant l'interface d'un composant existant (Adaptee)** vers une
**interface attendue par le client (Target)**. Il permet de r√©utiliser du code
sans le modifier (souvent du code tiers ou h√©rit√©) et limite le couplage.

---

## Quand l‚Äôutiliser ?

- R√©utiliser une classe existante dont l‚Äôinterface ne correspond pas au besoin
  du client.
- Int√©grer une **librairie tierce** ou **du code existant** difficile √† modifier.
- **Isoler** l‚Äôusage d‚Äôune API externe pour faciliter les tests et √©viter sa
  propagation.
- **Remplacer** un composant par un autre sans changer le code client (adapter
  l‚Äôun √† l‚Äôinterface de l‚Äôautre).

---

## Diagrammes de classes

```mermaid
classDiagram
    class Client
    class Target {
        +request()
    }
    class Adaptee {
        +specific_request()
    }
    class Adapter {
        -adaptee: Adaptee
        +request()
    }

    Client --> Target
    Adapter ..|> Target
    Adapter o--> Adaptee
```

- Le client d√©pend de `Target` (contrat attendu).
- `Adapter` impl√©mente `Target` et **d√©l√®gue** √† une instance d‚Äô`Adaptee`.
- D√©couplage fort, remplacement ais√© de l‚Äôadaptee et testabilit√© accrue.

## Impl√©mentations en Python

<Tabs>
<TabItem value="logger" label="Logger">

Contexte: le client travaille avec `Logger` (m√©thode `log(msg)`), alors qu‚Äôune
librairie tierce expose `ThirdPartyLog.write(level, message)`.

```python
from abc import ABC, abstractmethod

# Interface cible (Target)
class Logger(ABC):
    @abstractmethod
    def log(self, message: str) -> None: ...

# Adaptee (API tierce/legacy)
class ThirdPartyLog:
    def write(self, level: str, message: str) -> None:
        print(f"[{level.upper()}] {message}")

# Adapter par composition
class ThirdPartyLogAdapter(Logger):
    def __init__(self, adaptee: ThirdPartyLog, default_level: str = "info") -> None:
        self._adaptee = adaptee
        self._level = default_level

    def log(self, message: str) -> None:
        # On adapte l'appel: log(msg) -> write(level, message)
        self._adaptee.write(self._level, message)

# Client
def client_code(logger: Logger) -> None:
    logger.log("D√©marrage du service‚Ä¶")

# Utilisation
adaptee = ThirdPartyLog()
adapter = ThirdPartyLogAdapter(adaptee, default_level="debug")
client_code(adapter)
```

Points cl√©s:
- Le client ne conna√Æt que `Logger`.
- L‚Äôadapteur traduit `log(msg)` en `write(level, message)`.
- Facile √† tester (on peut injecter un faux `ThirdPartyLog`).

</TabItem>
<TabItem value="Encodage" label="Encodage">

Adapter une API renvoyant des bytes vers une interface unicode.

```python
from abc import ABC, abstractmethod

class Reader(ABC):  # Target
    @abstractmethod
    def read_text(self) -> str: ...

class ByteSource:  # Adaptee
    def read_bytes(self) -> bytes:
        return b"Bonjour, monde!\n"

class ByteToTextReader(Reader):  # Adapter (composition)
    def __init__(self, source: ByteSource, encoding: str = "utf-8") -> None:
        self._src = source
        self._enc = encoding

    def read_text(self) -> str:
        return self._src.read_bytes().decode(self._enc)

r = ByteToTextReader(ByteSource())
print(r.read_text().strip())  # Bonjour, monde!
```

</TabItem>

<TabItem value="Prises" label="Prises √©lectriques">

Un exemple tir√©e de la vie courante: un appareil am√©ricain (110V) doit √™tre
utilis√© avec une prise europ√©enne (220V).

```python
from abc import ABC, abstractmethod

# Interface pour la prise am√©ricaine et appareil
# qui utilise l'√©lectricit√© √† 110V

class IPriseAmericaine(ABC):
    @abstractmethod
    def fournir_electricite_110(self) -> float:
        ...

class AppareilAmericain:
    def __init__(self):
        self.voltage = 110

    def utiliser(self, prise: IPriseAmericaine):
        print(f"Utilisation de l'appareil am√©ricain avec {prise.fournir_electricite_110()}V")

# Mais seulement une prise europ√©enne est disponible
class PriseEuropeenne:
    def fournir_electricite_220(self):
        return 220

class Adaptateur(IPriseAmericaine):
    def __init__(self, priseEuro: PriseEuropeenne):
        self.priseEuro = priseEuro
    
    def fournir_electricite_110(self):
        return self.priseEuro.fournir_electricite_220() / 2

if __name__ == "__main__":
    priseEuro = PriseEuropeenne()
    adaptateur = Adaptateur(priseEuro)
    appareil = AppareilAmericain()
    appareil.utiliser(adaptateur)
```
</TabItem>
</Tabs>
---

## Avantages et inconv√©nients

**Avantages**
- R√©utilisation de code existant sans le modifier.
- D√©couplage du client vis‚Äë√†‚Äëvis d‚ÄôAPI tierces/existantes.
- Simplifie la migration vers une nouvelle impl√©mentation (changer l‚Äôadapter).
- Facilite les tests (injection de doublures c√¥t√© adaptee).

**Inconv√©nients**
- Multiplie parfois les couches.

### Astuces pratiques

- Documenter clairement la correspondance des m√©thodes adapt√©es.
- Pour les formats/protocoles, valider les conversions (encodage, unit√©s, etc.).

---

## R√©f√©rences

- https://refactoring.guru/design-patterns/adapter
- https://en.wikipedia.org/wiki/Adapter_pattern

