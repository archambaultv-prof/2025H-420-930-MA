---
sidebar_position: 4
sidebar_label: Patron observateur
description: Patron observateur
---

# üëì Patron observateur


Lorsqu'un √©v√©nement survient dans un programme, il est souvent n√©cessaire de
notifier plusieurs parties de l'application. Le patron observateur permet de
g√©rer cette relation de mani√®re efficace et flexible. Il est particuli√®rement
utile dans les applications o√π plusieurs composants doivent r√©agir √† des
changements d'√©tat d'un objet central.


Le patron observateur (Observer) permet de d√©finir une relation un-√†-plusieurs
entre objets, de sorte que lorsque l'√©tat d'un objet (le *sujet*) change, tous
ses *observateurs* sont automatiquement notifi√©s et mis √† jour.

## Quand l‚Äôutiliser ?

- Pour **d√©coupler** des objets producteurs d‚Äô√©v√©nements et consommateurs.
- Mise en ≈ìuvre d‚Äôun **syst√®me d‚Äô√©v√©nements** ou de **callbacks**.
- **Interfaces graphiques** : notifier plusieurs composants √† chaque modification de donn√©es.
- **Gestion de notifications** : envoi d‚Äôalertes, log, UI, etc.

## Diagramme de classes

Le diagramme de classes ci-dessous illustre la structure du patron observateur :

```mermaid
classDiagram

    class Sujet {
        +attacher(o: IObservateur)
        +detacher(o: IObservateur)
        +notifier()
    }
    class SujetConcret {
        -etat
        +obtenir_etat()
        +definir_etat(etat)
    }
    class IObservateur {
        +mise_a_jour(sujet: Sujet)
    }
    class ObservateurConcret {
        -nom: str
        -etat_observateur
        +mise_a_jour(sujet: Sujet)
    }

    Sujet <|-- SujetConcret
    IObservateur <|.. ObservateurConcret
    Sujet o-- IObservateur
``` 


La classe qui √©met les notifications est appel√©e `Sujet`. Elle maintient une
liste d'observateurs et notifie chacun d'eux lorsqu'un changement d'√©tat se
produit. Si l'on veut respecter les principes SOLID, cette classe ne g√®re que
les notifications et ne contient pas de logique m√©tier. Ce sont les sous-classes (`SujetConcret`)
qui impl√©mentent la logique m√©tier.


Les classes `IObservateur` et `ObservateurConcret` d√©finissent le contrat
pour les observateurs. Chaque observateur doit impl√©menter la m√©thode `mise_a_jour`
qui sera appel√©e par le sujet lorsqu'un changement d'√©tat se produit.

## Impl√©mentation en Python


Dans cet exemple, le sujet et le sujet concret sont fusionn√©s pour simplifier
la d√©monstration.

```python
from abc import ABC, abstractmethod

class Observateur(ABC):
    @abstractmethod
    def mise_a_jour(self, sujet):
        pass

class Sujet:
    def __init__(self):
        self._observateurs = []
        self._etat = None


    def attacher(self, observateur: Observateur):
        self._observateurs.append(observateur)


    def detacher(self, observateur: Observateur):
        self._observateurs.remove(observateur)


    def notifier(self):
        for obs in self._observateurs:
            obs.mise_a_jour(self)


    def obtenir_etat(self):
        return self._etat


    def definir_etat(self, etat):
        self._etat = etat
        self.notifier()

class ObservateurConcret(Observateur):

    def __init__(self, nom: str):
        self._nom = nom
        self._etat_observateur = None


    def mise_a_jour(self, sujet: Sujet):
        self._etat_observateur = sujet.obtenir_etat()
        print(f"{self._nom} a re√ßu une mise √† jour : {self._etat_observateur}")
``` 


### Exemple d'utilisation

```python
if __name__ == '__main__':

    sujet = Sujet()

    obs1 = ObservateurConcret('Observateur A')
    obs2 = ObservateurConcret('Observateur B')

    sujet.attacher(obs1)
    sujet.attacher(obs2)

    sujet.definir_etat('√âtat initial')
    # Observateur A a re√ßu une mise √† jour : √âtat initial
    # Observateur B a re√ßu une mise √† jour : √âtat initial

    sujet.definir_etat('Nouvelle valeur')
    # Observateur A a re√ßu une mise √† jour : Nouvelle valeur
    # Observateur B a re√ßu une mise √† jour : Nouvelle valeur
``` 

## Exemple fait en classe

Ceci est le code que nous avons fait en classe pour illustrer le patron observateur.

```python
from abc import ABC, abstractmethod


class IObservateur(ABC):
    @abstractmethod
    def mettre_a_jour(self, nb_participants):
        pass

class Admin(IObservateur):
    def mettre_a_jour(self, nb_participants):
        print(f"[Admin] : Le cours aura bien lieu avec {nb_participants} participants.")

class Participants(IObservateur):
    def mettre_a_jour(self, nb_participants):
        for i in range(nb_participants):
            print(f"[Participant {i + 1}] : Le cours aura bien lieu.")

class ServiceInformatique(IObservateur):
    def mettre_a_jour(self, nb_participants):
        print(f"[Service informatique] : Le cours aura bien lieu avec {nb_participants} participants.")

class Professeur(IObservateur):
    def __init__(self, notification=True):
        self.notification = notification

    def mettre_a_jour(self, nb_participants):
        if self.notification:
            print(f"[Professeur] : Le cours aura bien lieu avec {nb_participants} participants.")

class Emetteur:
    def __init__(self):
        self.observateurs: list[IObservateur] = []

    def ajouter_observateur(self, observateur: IObservateur):
        self.observateurs.append(observateur)

    def retirer_observateur(self, observateur: IObservateur):
        if observateur in self.observateurs:
            self.observateurs.remove(observateur)

    def notifier_observateurs(self, nb_participants):
        for observateur in self.observateurs:
            observateur.mettre_a_jour(nb_participants)

class Cours(Emetteur):
    def __init__(self, nom):
        super().__init__()
        self.nom = nom
        self.participants = 0

    def ajouter_participant(self):
        self.participants += 1
        if self.participants == 5:
            self.notifier_observateurs(self.participants)


class Tutorat(Emetteur):
    def __init__(self, nom):
        super().__init__()
        self.nom = nom
        self.participants = 0

    def ajouter_participant(self):
        self.participants += 1
        if self.participants == 3:
            self.notifier_observateurs(self.participants)

a = Cours("Yoga")
a.ajouter_observateur(Admin())
a.ajouter_observateur(Participants())
a.ajouter_observateur(ServiceInformatique())
a.ajouter_observateur(Professeur(False))
for i in range(10):
    a.ajouter_participant()
```

## Avantages et inconv√©nients


**Avantages**
- Faible couplage entre √©metteur et r√©cepteurs.
- Extensible : on peut ajouter de nouveaux observateurs sans modifier le sujet.


**Inconv√©nients**
- Risque de **fuites de m√©moire** si l'on oublie de d√©tacher.
- Ordre de notification **non garanti**.
- Difficile √† d√©boguer s'il y a de nombreux observateurs.


## R√©f√©rences

- https://refactoring.guru/design-patterns/observer
- https://en.wikipedia.org/wiki/Observer_pattern
