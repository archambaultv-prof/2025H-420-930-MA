---
sidebar_position: 5
sidebar_label: Patrons factory et abstract factory
description: Patrons factory et abstract factory
---

# üè≠ Patrons factory et abstract factory

Le terme ¬´¬†factory¬†¬ª regroupe plusieurs variantes ayant pour objectif principal
de **d√©l√©guer la cr√©ation d'objets** √† un composant sp√©cialis√© plut√¥t que
d'instancier directement des classes concr√®tes dans le code client. Cela r√©duit
le couplage, centralise la logique d'instanciation et facilite l'extension.

Dans la litt√©rature des patrons GoF, on distingue principalement :

- Simple Factory (souvent utilis√©e mais pas un patron ¬´ officiel ¬ª GoF) ‚Äì centralise la cr√©ation.
- Factory Method ‚Äì laisse les sous-classes d√©cider des classes concr√®tes √† instancier.
- Abstract Factory ‚Äì cr√©e des familles d‚Äôobjets coh√©rentes sans pr√©ciser leurs classes concr√®tes.

---

## Quand l‚Äôutiliser ?

- Lorsque le code client **ne doit pas conna√Ætre** les classes concr√®tes instanci√©es.
- Quand la logique de cr√©ation est **complexe**, conditionnelle ou d√©pend d'entr√©es externes (config, donn√©es, contexte).
- Pour **remplacer des constructions `if/elif` / `match` r√©p√©titives** dispers√©es dans le projet.
- Pour **regrouper la cr√©ation de familles d‚Äôobjets compatibles** (Abstract Factory).
- Pour **faciliter les tests** (injection de factories simul√©es / mocks).
- Pour **appliquer le principe Ouvert/Ferm√© (OCP)** : ajouter un nouveau produit sans modifier le client existant.

---

## Diagrammes de classes

### Factory Method

```mermaid
classDiagram
	class Produit {
		+operation()
	}
	class ProduitConcretA {
		+operation()
	}
	class ProduitConcretB {
		+operation()
	}
	class Createur {
		+fabriquer(): Produit
		+logique_metier()
	}
	class CreateurConcretA {
		+fabriquer(): Produit
	}
	class CreateurConcretB {
		+fabriquer(): Produit
	}

	Produit <|.. ProduitConcretA
	Produit <|.. ProduitConcretB
	Createur <|-- CreateurConcretA
	Createur <|-- CreateurConcretB
	Createur --> Produit
```

Le client manipule `Createur` et reste d√©coupl√© des produits concrets.

#### Explication du diagramme (Factory Method)

- `Produit` : interface (ou classe abstraite) commune que le client utilisera.
- `ProduitConcretA` / `ProduitConcretB` : impl√©mentations sp√©cifiques de `Produit`.
- `Createur` : d√©finit la m√©thode **factory** abstraite `fabriquer()` et peut contenir de la logique m√©tier (`logique_metier`) qui s'appuie sur l'objet retourn√© sans conna√Ætre sa classe concr√®te.
- `CreateurConcretA` / `CreateurConcretB` : sp√©cialisent la cr√©ation en retournant respectivement `ProduitConcretA` ou `ProduitConcretB`.


Id√©e cl√© : pour introduire un nouveau produit, on ajoute une sous-classe de `Createur` et une classe de produit ‚Äî le code client qui consomme `Createur` n'est pas modifi√©.

### Abstract Factory (famille de produits)

```mermaid
classDiagram
	class FabriqueAbstraite {
		+creer_produit_a(): ProduitA
		+creer_produit_b(): ProduitB
	}
	class FabriqueConcrete1 {
		+creer_produit_a(): ProduitA
		+creer_produit_b(): ProduitB
	}
	class FabriqueConcrete2 {
		+creer_produit_a(): ProduitA
		+creer_produit_b(): ProduitB
	}
	class ProduitA {
		+feature_a()
	}
	class ProduitA1 {
		+feature_a()
	}
	class ProduitA2 {
		+feature_a()
	}
	class ProduitB {
		+feature_b()
	}
	class ProduitB1 {
		+feature_b()
	}
	class ProduitB2 {
		+feature_b()
	}

	FabriqueAbstraite <|-- FabriqueConcrete1
	FabriqueAbstraite <|-- FabriqueConcrete2
	ProduitA <|.. ProduitA1
	ProduitA <|.. ProduitA2
	ProduitB <|.. ProduitB1
	ProduitB <|.. ProduitB2
	FabriqueAbstraite --> ProduitA
	FabriqueAbstraite --> ProduitB
```

Chaque fabrique concr√®te produit une **famille coh√©rente** (`ProduitA1` avec `ProduitB1`, etc.).

#### Explication du diagramme (Abstract Factory)

- `FabriqueAbstraite` : contrat regroupant les m√©thodes de cr√©ation pour chaque type de produit de la famille (`creer_produit_a`, `creer_produit_b`).
- `FabriqueConcrete1` / `FabriqueConcrete2` : fournissent des combinaisons coh√©rentes d'impl√©mentations concr√®tes (ex. th√®me clair vs sombre, SGBD MySQL vs PostgreSQL, etc.).
- `ProduitA` / `ProduitB` : interfaces (ou classes abstraites) des diff√©rentes cat√©gories de produits.
- `ProduitA1` / `ProduitA2` et `ProduitB1` / `ProduitB2` : variantes concr√®tes appartenant √† des familles correspondantes (1 ou 2).
- Les fabriques concr√®tes garantissent la coh√©rence interne : en choisissant une fabrique, on obtient automatiquement une famille de composants compatibles entre eux.
- Le client d√©pend uniquement de `FabriqueAbstraite` et des interfaces `ProduitA` / `ProduitB`, ce qui permet de changer toute la famille d'objets en injectant une autre fabrique.

Id√©e cl√© : changer d‚Äôenvironnement / th√®me / fournisseur = remplacer la fabrique inject√©e, sans toucher au reste du code.

---

## Impl√©mentations en Python

### 1. Simple Factory (centralisation basique)

> Pas un patron GoF formel, mais tr√®s courant. Utile pour remplacer des blocs conditionnels dispers√©s.

```python
from abc import ABC, abstractmethod

class Forme(ABC):
	@abstractmethod
	def aire(self): ...

class Cercle(Forme):
	def __init__(self, r: float):
		self.r = r
	def aire(self):
		return 3.1416 * self.r ** 2

class Carre(Forme):
	def __init__(self, cote: float):
		self.cote = cote
	def aire(self):
		return self.cote ** 2

class FormeFactory:
	@staticmethod
	def creer(type_forme: str, *args) -> Forme:
		match type_forme.lower():
			case 'cercle':
				return Cercle(*args)
			case 'carre':
				return Carre(*args)
			case _:
				raise ValueError(f"Type de forme inconnu: {type_forme}")

f1 = FormeFactory.creer('cercle', 2)
f2 = FormeFactory.creer('carre', 3)
print(f1.aire(), f2.aire())  # 12.5664 9
```

Limite : ajouter un type implique de modifier la factory (pas totalement conforme au principe Ouvert/Ferm√© ‚Äì OCP).

### 2. Factory Method (GoF)

Ici, la m√©thode de cr√©ation (`fabriquer`) est **d√©port√©e dans les sous-classes**. Le code m√©tier dans la classe de base peut utiliser le produit abstrait sans conna√Ætre sa classe concr√®te.

```python
from abc import ABC, abstractmethod

class Document(ABC):
	@abstractmethod
	def exporter(self) -> str: ...

class PDF(Document):
	def exporter(self) -> str:
		return "Export PDF"

class CSV(Document):
	def exporter(self) -> str:
		return "Export CSV"

class Createur(ABC):
	def logique_metier(self) -> str:
		doc = self.fabriquer()
		return f"[LOG] {doc.exporter()}"

	@abstractmethod
	def fabriquer(self) -> Document: ...

class CreateurPDF(Createur):
	def fabriquer(self) -> Document:
		return PDF()

class CreateurCSV(Createur):
	def fabriquer(self) -> Document:
		return CSV()

def client(createur: Createur):
	print(createur.logique_metier())

client(CreateurPDF())  # [LOG] Export PDF
client(CreateurCSV())  # [LOG] Export CSV
```

Avantage : pour un nouveau format, on cr√©e une nouvelle sous-classe sans modifier le client.

### 3. Abstract Factory (familles de produits)

On encapsule la cr√©ation d‚Äôobjets qui doivent fonctionner ensemble (ex. UI sombre vs claire, drivers de base de donn√©es, widgets multi-plateforme).

```python
from abc import ABC, abstractmethod

# Produits abstraits
class Bouton(ABC):
	@abstractmethod
	def dessiner(self) -> str: ...

class Fenetre(ABC):
	@abstractmethod
	def ouvrir(self) -> str: ...

# Impl√©mentations concr√®tes (Th√®me Clair)
class BoutonClair(Bouton):
	def dessiner(self) -> str:
		return "Bouton clair"

class FenetreClair(Fenetre):
	def ouvrir(self) -> str:
		return "Fen√™tre claire"

# Impl√©mentations concr√®tes (Th√®me Sombre)
class BoutonSombre(Bouton):
	def dessiner(self) -> str:
		return "Bouton sombre"

class FenetreSombre(Fenetre):
	def ouvrir(self) -> str:
		return "Fen√™tre sombre"

# Fabrique abstraite
class UIFactory(ABC):
	@abstractmethod
	def creer_bouton(self) -> Bouton: ...
	@abstractmethod
	def creer_fenetre(self) -> Fenetre: ...

class UIFactoryClair(UIFactory):
	def creer_bouton(self) -> Bouton:
		return BoutonClair()
	def creer_fenetre(self) -> Fenetre:
		return FenetreClair()

class UIFactorySombre(UIFactory):
	def creer_bouton(self) -> Bouton:
		return BoutonSombre()
	def creer_fenetre(self) -> Fenetre:
		return FenetreSombre()

def rendre_ui(factory: UIFactory):
	b = factory.creer_bouton()
	f = factory.creer_fenetre()
	print(b.dessiner())
	print(f.ouvrir())

rendre_ui(UIFactoryClair())
rendre_ui(UIFactorySombre())
```

Changer de th√®me = injecter une autre fabrique sans toucher au code m√©tier.

---

## Comparaison rapide

| Variante | Intention | Extension |
|----------|-----------|-----------|
| Simple Factory | Centraliser des constructions | Modifier la factory |
| Factory Method | Laisser les sous-classes d√©cider | Ajouter une sous-classe |
| Abstract Factory | Produire des familles coh√©rentes | Ajouter une fabrique |

---

## Avantages et inconv√©nients

**Avantages**
- R√©duction du couplage aux classes concr√®tes (d√©pendance envers des abstractions).
- Centralisation / encapsulation de la logique d‚Äôinstanciation.
- Facilite les tests (injection de factory mock / stub).
- Ouvre la porte au polymorphisme et au remplacement dynamique.

**Inconv√©nients**
- Multiplication des classes (surtout avec Abstract Factory).
- Peut para√Ætre sur‚Äëing√©nier√© pour des cas simples.
- Cha√Ænage de niveaux d‚Äôabstraction pouvant complexifier le d√©bogage.
- Simple Factory casse OCP (modification pour chaque nouveau type) si non combin√©e avec enregistrement dynamique.

### Astuces pratiques

- Utiliser un **registre dynamique** (ex. : dict type -> classe) pour √©viter d‚Äô√©diter la factory.
- Combiner avec **Singleton** si la factory elle-m√™me doit √™tre unique.
- Pour la config / l‚Äôinjection : passer la factory en param√®tre plut√¥t que d‚Äôappeler une variable globale.

---

## R√©f√©rences

- https://refactoring.guru/design-patterns/factory-method
- https://refactoring.guru/design-patterns/abstract-factory
- https://en.wikipedia.org/wiki/Factory_method_pattern
- https://en.wikipedia.org/wiki/Abstract_factory_pattern
