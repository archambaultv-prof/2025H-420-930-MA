---
sidebar_label: Singleton et invertion des d√©pendances
sidebar_position: 2
description: Singleton et inversion des d√©pendances
---

# üîÇ Singleton et invertion des d√©pendances

## üéØ Objectifs p√©dagogiques

- Mettre en pratique le patron de conception Singleton.
- Comprendre l'inversion des d√©pendances et son utilit√©.

## üìú √ânonc√©

Le code ci-dessous impl√©mente un service de configuration qui doit √™tre unique
dans l'application. Il n'utilise pas le patron singleton ni l'inversion des
d√©pendances. Vous devez r√©√©crire le code et l'adapter pour respecter ces
principes selon les intructions d√©taill√©es plus bas.

```python
import json
import os

# Code probl√©matique √† refactoriser
class ConfigurationService:
    def __init__(self, config_file="config.json"):
        self.config_file = os.path.join(os.path.dirname(__file__), config_file)
        self.config = {}
        self.load_config()
    
    def load_config(self):
        if os.path.exists(self.config_file):
            with open(self.config_file, 'r') as f:
                self.config = json.load(f)
        else:
            # Configuration par d√©faut
            self.config = {
                "database_url": "localhost:5432",
                "api_key": "default_key",
                "debug_mode": True,
                "max_connections": 10
            }
    
    def get_config(self, key):
        return self.config.get(key)
    
    def set_config(self, key, value):
        self.config[key] = value
    
    def save_config(self):
        with open(self.config_file, 'w') as f:
            json.dump(self.config, f, indent=2)

class DatabaseConnection:
    def __init__(self):
        # Probl√®me: cr√©ation directe d'une d√©pendance
        self.config_service = ConfigurationService()
        self.connection_string = self.config_service.get_config("database_url")
        self.max_connections = self.config_service.get_config("max_connections")
    
    def connect(self):
        print(f"Connexion √† la base de donn√©es: {self.connection_string}")
        print(f"Nombre max de connexions: {self.max_connections}")

class ApiClient:
    def __init__(self):
        # Probl√®me: cr√©ation directe d'une autre instance
        self.config_service = ConfigurationService()
        self.api_key = self.config_service.get_config("api_key")
        self.debug_mode = self.config_service.get_config("debug_mode")
    
    def make_request(self, endpoint):
        debug_info = f" [DEBUG MODE]" if self.debug_mode else ""
        print(f"Requ√™te API vers {endpoint} avec cl√©: {self.api_key}{debug_info}")

class Logger:
    def __init__(self):
        # Probl√®me: encore une autre instance
        self.config_service = ConfigurationService()
        self.debug_mode = self.config_service.get_config("debug_mode")
    
    def log(self, message):
        if self.debug_mode:
            print(f"[LOG] {message}")

# Code d'utilisation probl√©matique
def main():
    # Chaque classe cr√©e sa propre instance de ConfigurationService
    db = DatabaseConnection()
    api = ApiClient()
    logger = Logger()

    db.connect()
    api.make_request("/users")
    logger.log("Application d√©marr√©e")

    # Si on modifie la configuration dans une instance...
    db.config_service.set_config("debug_mode", False)
    db.config_service.save_config()

    # Les autres instances ne voient pas le changement!
    logger.log("Cette ligne devrait-elle s'afficher?")

if __name__ == "__main__":
    main()
```

### üîç Analyse des probl√®mes

Le code ci-dessus pr√©sente plusieurs probl√®mes majeurs :

#### 1. Absence du patron Singleton
- Chaque classe cr√©e sa propre instance de `ConfigurationService`
- Cela peut mener √† des incoh√©rences dans la configuration
- Les modifications ne sont pas partag√©es entre les instances

#### 2. Violation du principe d'inversion des d√©pendances
- Les classes `DatabaseConnection`, `ApiClient` et `Logger` cr√©ent directement leurs d√©pendances
- Elles sont fortement coupl√©es √† `ConfigurationService`
- Difficile de tester unitairement ou de changer l'impl√©mentation

#### 3. Probl√®mes de synchronisation
- Si une partie de l'application modifie la configuration, les autres parties ne le voient pas
- Risque d'√©tats incoh√©rents dans l'application

### üìã Instructions d√©taill√©es

#### Partie 1: Impl√©mentation du patron Singleton

Transformez la classe `ConfigurationService` en Singleton en utilisant  la
m√©thode sp√©ciale `__new__` pour contr√¥ler la cr√©ation de l'instance.

#### Partie 2: Application de l'inversion des d√©pendances

Refactorisez les classes `DatabaseConnection`, `ApiClient` et `Logger` pour
qu'elles respectent le principe d'inversion des d√©pendances.

#### Partie 2.1 Cr√©ation d'une interface abstraite

Cr√©ez une classe abstraite `ConfigInterface` qui d√©finit le contrat :

```python
from abc import ABC, abstractmethod

class ConfigInterface(ABC):
    @abstractmethod
    def get_config(self, key: str):
        pass
    
    @abstractmethod
    def set_config(self, key: str, value):
        pass
```

#### Partie 2.2 Injection de d√©pendances

Modifiez les classes pour qu'elles re√ßoivent leur d√©pendance via le constructeur.
